#!/usr/bin/env ruby
=begin
  vim: sw=2:
  Copyright (c) 2012, Gennady Bystritsky <bystr@mac.com>

  Distributed under the MIT Licence.
  This is free software. See 'LICENSE' for details.
  You must read and accept the license prior to use.

  Author: Gennady Bystritsky
=end

$:.concat ENV.to_hash['PATH'].to_s.split(File::PATH_SEPARATOR)

require 'tsc/application.rb'
require 'tsc/path.rb'

class Application < TSC::Application
  in_generator_context do |_content|
    _content << '#!/usr/bin/env ' + figure_ruby_path
    _content << '$LOAD_PATH.unshift ' + File.dirname(figure_ruby_path).inspect
    _content << 'PLATFORM_TOP = ' + self.class.installation_parameters[:platform_top].inspect
    _content << 'APP_NAME = ' + self.class.installation_parameters[:app_env_name].inspect
    _content << 'APP_VERSION = ' + self.class.installation_parameters[:app_version].inspect

    _content << IO.readlines(__FILE__).slice(1..-1)
  end

  def start
    handle_errors do
      require 'pathname'

      scan_env_for_versioned_facilities
      process_command_line figure_command_line(script_name, ARGV)
    end
  end

  private
  #######

  def app_version
    @app_version ||= defined?(APP_NAME) ? APP_VERSION : begin
      raise 'Version info not available'
    end
  end

  def app_names
    @app_names ||= [ (APP_NAME if defined?(APP_NAME)), 'app-env' ].compact
  end

  def env_name_components_list
    @env_name_components_list ||= app_names.map { |_name|
      _name.split(%r{[-_]}).tap { |_components|
        _components.pop if _components.last == 'env'
        break _components.push('v').map(&:upcase)
      }
    }
  end

  def env_name_main_list
    @env_name_main_list ||= env_name_components_list.map { |_components|
      _components.join('_')
    }
  end

  def env_name_prefix_list
    @env_name_prefix_list ||= env_name_main_list.map { |_main|
      _main + '_'
    }
  end

  def facilities
    @facilities ||= []
  end

  def validate_and_setup_facilities
    TSC::Error.persist do |_actions|
      facilities.each do |_item|
        platform_top(_item).tap do |_folder|
          _actions.add {
            raise "No #{_folder}" unless _folder.exist?
            app_env_path.front _folder
          }
        end
      end
    end
  end

  def process_command_line(args)
    until args.empty? or args.first.index('--') != 0
      case args.shift
        when '--validate'
          env_main_values.each do |_value|
            next if [ '', 'on', 'off' ].include? _value
            next if app_version == _value

            raise "Version mismatch: #{app_version} instead of required #{_value}"
          end

        when '--report'
          puts "#{script_real_name}: Current version: #{app_version}"
          @info = true
      end
    end

    validate_and_setup_facilities
    print_info script_real_location.parent, app_env_path.entries

    system_lib_path.front(platform_top, app_env_path.entries.reverse) { |_entry|
      [ _entry.join('lib'), _entry.join('lib64') ]
    }
    system_path.front(platform_top, app_env_path.entries.reverse) { |_entry|
      _entry.join('bin')
    }
    system_path.front script_real_location

    launch *args unless args.empty?
    raise 'No command specified'
  end

  def launch(command, *args)
    system_path.find_all(command).each do |_item|
      next if _item == $0
      next if _item == myself

      app_env_path.install
      system_lib_path.install
      system_path.install

      exec _item, *args
    end

    raise "Command not found: #{command}"
  end

  def print_info(*args)
    return unless @info
    args.flatten.compact.each do |_item|
      puts "INFO: #{_item}"
    end
  end

  def myself
    @myself ||= script_real_location.join(script_name).to_s
  end

  def normalize_array(*array)
    array.flatten.compact
  end

  def env_main_values
    @env_main_values ||= normalize_array env_name_main_list.map { |_name|
      ENV[_name]
    }
  end

  def scan_env_for_versioned_facilities
    return if env_main_values.empty? or env_main_values.any? { |_value|
      [ '', 'off' ].include? _value
    }
    env_name_main_list.each do |_name|
      ENV[_name] &&= 'off'
    end

    ENV.to_hash.each do |_name, _value|
      env_name_prefix_list.each do |_prefix|
        next unless _name.index(_prefix) == 0
        ENV.delete(_name)
        facilities << _name.slice(_prefix.size .. -1).split('_').map(&:downcase).push(_value).join('-')
      end
    end
  end

  def exec(*args)
    puts "### #{args.join(' ')}" if verbose?
    Kernel.exec *args
  end

  def app_env_path
    @app_env_path ||= TSC::Path['APP_ENV_PATH'].load
  end

  def system_path
    @system_path ||= TSC::PATH.new.load
  end

  def system_lib_path
    @system_lib_path ||= TSC::Path['LD_LIBRARY_PATH:SHLIB_PATH:LIBPATH'].load
  end

  def figure_command_line(name, args)
    case name
      when *app_names
        scan_for_versioned_facilities(args)

      when %r{^(.+)-env$}
        scan_for_version($1, args)

      else
        [ name, *args ]
    end
  end

  def scan_for_versioned_facilities(items)
    until items.empty?
      break unless items.first =~ %r{^(.+)-\d+([.]\d+)+.?$}
      facilities << items.shift
    end

    items
  end

  def scan_for_version(facility, items)
    until items.empty?
      break unless items.first =~ %r{^\d+([.]\d+)+.?$}
      facilities << facility + '-' + items.shift
    end

    scan_for_versioned_facilities(items)
  end

  def platform_top(*args)
    (@platform_top ||= figure_platform_top).join *args
  end

  def figure_platform_top
    return Pathname.new(PLATFORM_TOP) if defined? PLATFORM_TOP

    TSC::Error.wrap_with 'Platform top cannot be determined' do
      case find_in_path('ruby').first
        when nil
          raise 'No ruby'

        when %r{^(.+/platform/.+?)(/ruby-\d+([.]\d+)+)?/bin/ruby$}
          return Pathname.new($1)

        else
          raise 'No platform bound ruby'
      end
    end
  end
end

Application.new.start
