#!/usr/bin/env ruby
=begin
  vim: sw=2:
  Copyright (c) 2012, Gennady Bystritsky <bystr@mac.com>

  Distributed under the MIT Licence.
  This is free software. See 'LICENSE' for details.
  You must read and accept the license prior to use.

  Author: Gennady Bystritsky
=end

$:.concat ENV['PATH'].to_s.split(File::PATH_SEPARATOR)

require 'tsc/application.rb'
require 'tsc/path.rb'

class Application < TSC::Application
  in_generator_context do |_content|
    _content << '#!/usr/bin/env ' + figure_ruby_path
    _content << '$LOAD_PATH.unshift ' + File.dirname(figure_ruby_path).inspect
    _content << 'PLATFORM_TOP = ' + self.class.installation_parameters[:platform_top].inspect
    _content << 'APP_NAME = ' + self.class.installation_parameters[:app_name].inspect
    _content << 'TOP = ' + File.join(self.class.installation_top, 'bin').inspect

    _content << IO.readlines(__FILE__).slice(1..-1)
  end

  def start
    handle_errors do
      require 'pathname'

      TSC::LD_LIBRARY_PATH.current.back(top('lib64'), top('lib')).install
      launch *figure_command_line(script_name, ARGV)
    end
  end

  private
  #######

  def app_names
    @app_names ||= [ (APP_NAME if defined?(APP_NAME)), 'app-env' ].compact
  end

  def env_name_components
    @env_name_components ||= app_names.first.split('-').tap { |_components|
      _components.pop if _components.first == 'env'
      break _components.push('v').map(&:upcase)
    }
  end

  def env_name_main
    @env_name_main ||= env_name_components.join('-')
  end

  def env_name_prefix
    @env_name_prefix ||= env_name_main + '_'
  end

  def folders
    @folders ||= []
  end

  def launch(*args)
    raise 'No command specified' if args.empty?

    folders.each do |_item|
      platform_top.join(_item).tap do |_folder|
        raise "No #{_folder}" unless _folder.exist?
        app_env_path.front(_folder.join('bin')).install
      end
    end

    system_path.front(top('bin')) unless system_path.entries.include?(top('bin'))

    system_path.front app_env_path.entries.reverse
    system_path.front TOP if defined? TOP

    args.shift.tap do |_command|
      system_path.entries.each do |_location|
        Dir[ File.join(_location, _command) ].each do |_item|
          next if _item == $0
          next if defined?(TOP) and _item == File.join(TOP, script_name)

          system_path.install
          exec _item, *args
        end
      end

      raise "Command not found: #{_command}"
    end
  end

  def exec(*args)
    puts "### #{args.join(' ')}" if verbose?
    Kernel.exec *args
  end

  def app_env_path
    @app_env_path ||= TSC::Path['APP_ENV_PATH'].load
  end

  def system_path
    @system_path ||= TSC::PATH.new.load
  end

  def figure_command_line(name, args)
    case name
      when *app_names
        scan_for_folders(args)

      when %r{^(.+)-env$}
        scan_for_version($1, args)

      else
        [ name, *args ]
    end
  end

  def scan_for_folders(items)
    until items.empty?
      break unless items.first =~ %r{^(.+)-\d+([.]\d+)+$}
      folders << items.shift
    end

    items
  end

  def scan_for_version(facility, items)
    until items.empty?
      break unless items.first =~ %r{^\d+([.]\d+)+$}
      folders << facility + '-' + items.shift
    end

    scan_for_folders(items)
  end

  def top(*args)
    platform_top.join(*args.flatten.compact).to_s
  end

  def platform_top
    @platform_top ||= figure_platform_top
  end

  def figure_platform_top
    return Pathname.new(PLATFORM_TOP) if defined? PLATFORM_TOP

    TSC::Error.wrap_with 'Platform top cannot be determined' do
      case find_in_path('ruby').first
        when nil
          raise 'No ruby'

        when %r{^(.+/platform/.+?)(/ruby-\d+([.]\d+)+)?/bin/ruby$}
          return Pathname.new($1)

        else
          raise 'No platform bound ruby'
      end
    end
  end
end

Application.new.start
