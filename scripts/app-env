#!/usr/bin/env ruby
=begin
  vim: sw=2:
  Copyright (c) 2012, Gennady Bystritsky <bystr@mac.com>

  Distributed under the MIT Licence.
  This is free software. See 'LICENSE' for details.
  You must read and accept the license prior to use.

  Author: Gennady Bystritsky
=end

$:.concat ENV.to_hash['PATH'].to_s.split(File::PATH_SEPARATOR)

require 'tsc/application.rb'
require 'tsc/path.rb'

class Application < TSC::Application
  in_generator_context do |_content|
    _content << '#!/usr/bin/env ' + figure_ruby_path
    _content << '$LOAD_PATH.unshift ' + File.dirname(figure_ruby_path).inspect
    _content << 'PLATFORM_TOP = ' + self.class.installation_parameters[:platform_top].inspect
    _content << 'APP_BASE = ' + self.class.installation_parameters[:app_env_base].inspect
    _content << 'APP_VERSION = ' + self.class.installation_parameters[:app_version].inspect

    _content << IO.readlines(__FILE__).slice(1..-1)
  end

  def start
    handle_errors do
      require 'pathname'

      process_command_line figure_command_line(script_name, ARGV)
    end
  end

  private
  #######

  def app_version
    @app_version ||= defined?(APP_VERSION) ? APP_VERSION : begin
      raise 'Version info not available'
    end
  end

  def app_base
    @app_base ||= defined?(APP_BASE) ? APP_BASE : 'app'
  end

  def facilities
    @facilities ||= []
  end

  def validate_and_setup_facilities
    TSC::Error.persist do |_actions|
      facilities.each do |_item, _version|
        next if _item == app_base

        platform_top([ _item, _version ].join('-')).tap do |_folder|
          _actions.add {
            raise "No #{_folder}" unless _folder.exist?
            app_env_path.front _folder
          }
        end
      end
    end
  end

  def app_env_base
    @app_env_base ||= app_base.split(%r{[_-]}).push('v').map(&:upcase).join('_')
  end

  def app_env_name(*items)
    app_env_base
  end

  def process_command_line(args)
    until args.empty? or args.first.index('--') != 0
      case args.shift
        when '--validate'
          ENV[app_env_base].tap do |_value|
            next if [ '', 'on', 'off' ].include? _value.to_s
            next if app_version == _value

            raise "Version mismatch: #{app_version} instead of required #{_value}"
          end

        when '--report'
          puts "#{script_real_name}: Current version: #{app_version}"
          @info = true
      end
    end

    validate_and_setup_facilities
    print_info script_real_location.parent, app_env_path.entries

    system_lib_path.front(platform_top, app_env_path.entries.reverse) { |_entry|
      [ _entry.join('lib'), _entry.join('lib64') ]
    }
    system_path.front(platform_top, app_env_path.entries.reverse) { |_entry|
      _entry.join('bin')
    }
    system_path.front script_real_location

    launch *args unless args.empty?
    raise 'No command specified'
  end

  def launch(command, *args)
    system_path.find_all(command).each do |_item|
      next if _item == $0
      next if _item == myself

      app_env_path.install
      system_lib_path.install
      system_path.install

      exec _item, *args
    end

    raise "Command not found: #{command}"
  end

  def print_info(*args)
    return unless @info
    args.flatten.compact.each do |_item|
      puts "INFO: #{_item}"
    end
  end

  def myself
    @myself ||= script_real_location.join(script_name).to_s
  end

  def normalize_array(*array)
    array.flatten.compact
  end

  def exec(*args)
    puts "### #{args.join(' ')}" if verbose?
    Kernel.exec *args
  end

  def app_env_path
    @app_env_path ||= TSC::Path['APP_ENV_PATH'].load
  end

  def system_path
    @system_path ||= TSC::PATH.new.load
  end

  def system_lib_path
    @system_lib_path ||= TSC::Path['LD_LIBRARY_PATH:SHLIB_PATH:LIBPATH'].load
  end

  def figure_command_line(name, args)
    case name
      when %r{^(.+)-env$}
        scan_for_versioned_facilities scan_for_version($1, args)

      else
        [ name, *args ]
    end
  end

  def scan_for_versioned_facilities(items)
    until items.empty?
      break unless items.first =~ %r{^(.+)-(.+)$}
      break unless scan_for_version($1, [ $2 ]).empty?

      items.shift
    end

    items
  end

  def scan_for_version(facility, items)
    until items.empty?
      break unless items.first =~ %r{^\d+([.]\d+)+.?$}
      facilities << [ facility, items.shift ]
    end

    items
  end

  def platform_top(*args)
    (@platform_top ||= figure_platform_top).join *args
  end

  def figure_platform_top
    return Pathname.new(PLATFORM_TOP) if defined? PLATFORM_TOP

    TSC::Error.wrap_with 'Platform top cannot be determined' do
      case find_in_path('ruby').first
        when nil
          raise 'No ruby'

        when %r{^(.+/platform/.+?)(/ruby-\d+([.]\d+)+)?/bin/ruby$}
          return Pathname.new($1)

        else
          raise 'No platform bound ruby'
      end
    end
  end
end

Application.new.start
