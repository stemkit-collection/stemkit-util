#!/usr/bin/env ruby
# Copyright (c) 2005, Gennady Bystritsky <bystr@mac.com>
# 
# Distributed under the MIT Licence.
# This is free software. See 'LICENSE' for details.
# You must read and accept the license prior to use.
#
# Author: Gennady Bystritsky

$:.concat ENV['PATH'].to_s.split(File::PATH_SEPARATOR)

require 'tsc/application.rb'
require 'tsc/path.rb'

class Application < TSC::Application
  def initialize
    super { |_config|
      _config.arguments = '<class_name> ...'
      _config.options = [
        [ '--target', 'Specify language to bake', 'language', '-t' ],
        [ '--config', 'Use config file', 'yaml file', '-c' ],
        [ '--namespace', "Use namespace ('.' or '::' for hierarchy)", 'string', '-n' ],
        [ '--local', 'Enforce file creation in the current directory', nil, '-l' ],
        [ '--indent', 'Use so many spaces for indent (2 by default)', 'number', '-i' ],
        [ '--print', 'Print out instead of creating files', nil, '-p' ],
        [ '--mode', 'Set generation mode (e.g. test, app, etc.)', 'mode', '-m' ],
        [ '--force', 'Force file override', nil, '-f' ],
        [ '--test', 'Run internal tests', nil ]
      ]
      _config.description = [
        "This utility performs code generation for c/c++ and ruby classes according",
        "to specification provided in a configuration file (src/config/new.yaml or",
        "~/.new.yaml)."
      ]
    }
  end

  def start
    handle_errors {
      process_command_line

      require 'sk/lingo/config.rb'
      require 'sk/lingo/cpp/baker.rb'
      require 'sk/lingo/ruby/baker.rb'
      require 'sk/lingo/sh/baker.rb'

      throw :TEST if options.has_key?('test')
      raise TSC::UsageError, 'Nothing to do' if ARGV.empty?

      TSC::Error.undo(Exception) do |_stack|
        baker = SK::Lingo::Baker.new(options, _stack)
        ARGV.each do |_name|
          generate _name, baker
        end
      end
    }
  end

  def global_namespace=(namespace)
    @global_namespace = split_namespace namespace
  end

  private
  #######

  def generate(filename, baker)
    basename, extension = filename.scan(%r{^(.+?)(?:[.](.+))?$}).first
    namespace = split_namespace(basename)
    name = namespace.pop

    baker.guess(name, global_namespace + namespace, extension.to_s)
  end

  def global_namespace
    @global_namespace ||= split_namespace options['namespace']
  end

  def split_namespace(namespace)
    namespace.to_s.split(%r{(?::+)|(?:[.])})
  end

  in_generator_context do |_content|
    _content << '#!' + figure_ruby_path
    _content << '$VERBOSE = nil'
    _content << TSC::PATH.current.front(File.dirname(figure_ruby_path)).to_ruby_eval
    _content << IO.readlines(__FILE__).slice(1..-1)
  end
end

unless defined? Test::Unit::TestCase
  catch :TEST do
    Application.new.start
    exit 0
  end
end

$VERBOSE = true

require 'test/unit'

class MockBaker < SK::Lingo::Baker
  attr_reader :trace

  def initialize
    super []
  end

  def cc_header(*args)
    add_trace 'cc_header', *args
  end

  def cc_body(*args)
    add_trace 'cc_body', *args
  end

  def c(*args)
    add_trace 'c', *args
  end

  private
  #######

  def add_trace(*args)
    (@trace ||= []).push args
  end
end

class ApplicationTest < Test::Unit::TestCase
  def test_split_namespace
    assert_equal [], @app.send(:split_namespace, '')
    assert_equal ['aaa'], @app.send(:split_namespace, 'aaa')
    assert_equal ['aaa', 'bbb'], @app.send(:split_namespace, 'aaa::bbb')
    assert_equal ['aaa', 'bbb'], @app.send(:split_namespace, 'aaa:bbb::')
    assert_equal ['aaa', 'bbb'], @app.send(:split_namespace, 'aaa.bbb')
  end

  def test_generate_raises_for_unsupported_extension
    assert_raises(RuntimeError) do
      invoke_generate 'Abc.ccccc'
    end
  end

  def test_generate_no_extension
    invoke_generate 'Abc'

    assert_equal 2, @baker.trace.size
    assert_equal 'Abc', @baker.trace.first[1]
    assert_equal [], @baker.trace.first[2]

    setup
    invoke_generate 'aaa::bbb:Abc'

    assert_equal 2, @baker.trace.size
    assert_equal 'Abc', @baker.trace.first[1]
    assert_equal ['aaa', 'bbb'], @baker.trace.first[2]
  end

  def test_generate_with_extension
    invoke_generate 'aaa::Abc.cc'

    assert_equal 1, @baker.trace.size
    assert_equal 'cc_body', @baker.trace.first[0]
    assert_equal 'Abc', @baker.trace.first[1]
    assert_equal ['aaa'], @baker.trace.first[2]
  end

  def test_global_namespace_prepended
    @app.global_namespace = 'vvv::zzz'
    invoke_generate 'aaa::Abc.h'

    assert_equal 1, @baker.trace.size
    assert_equal 'cc_header', @baker.trace.first[0]
    assert_equal 'Abc', @baker.trace.first[1]
    assert_equal ['vvv', 'zzz', 'aaa'], @baker.trace.first[2]
  end

  def test_global_namespace_used
    @app.global_namespace = 'vvv::zzz'
    invoke_generate 'Abc.c'

    assert_equal 1, @baker.trace.size
    assert_equal 'c', @baker.trace.first[0]
    assert_equal 'Abc', @baker.trace.first[1]
    assert_equal ['vvv', 'zzz'], @baker.trace.first[2]
  end

  def invoke_generate(name)
    @app.send :generate, name, @baker
  end

  def setup
    @baker = MockBaker.new
    @app = Application.new
  end

  def teardown
    @app = nil
    @baker = nil
  end
end

__END__
indent: 2

copyright_holders: |

authors: |

license: |

header_includes: |

body_includes: |
  <iostream>
  <iomanip>

extends: |

initializes: |

public_methods:

protected_methods:

private_methods:

data: |

factory:
  constructor(): |
  destructor(): |

test:
  class_init: |
    CPPUNIT_TEST_SUITE(#{FULL_CLASS_NAME});
      CPPUNIT_TEST(testSimple);
    CPPUNIT_TEST_SUITE_END();

  header_includes: |
    <cppunit/TestFixture.h>
    <cppunit/extensions/HelperMacros.h>

  body_top: |
    CPPUNIT_TEST_SUITE_REGISTRATION(#{FULL_CLASS_NAME});

  header_bottom: |

  body_includes: |

  extends: |
    public CppUnit::TestFixture

  initializes: |

  public_methods:
    void setUp(): |
    void tearDown(): |
    void testSimple(): |
      CPPUNIT_ASSERT_EQUAL(true, false);

  protected_methods:

  private_methods:

  data: |

  factory:

sh: |
  TRACE=no

  print_usage()
  {
    print_error "USAGE: ${progname} [-v][-o][-a<argument>]"
  }

  main()
  {
    trap "cleanup_and_exit 5" HUP INT QUIT TERM
    trap "cleanup" EXIT 

    unset OPTION ARGUMENT

    while getopts ":hvoa:" option; do
      case "${option}" in
        o)
          OPTION=yes
        ;;
        a)
          ARGUMENT="${OPTARG}"
        ;;
        v)
          TRACE=yes
        ;;
        h)
          print_usage_and_exit 0
        ;;
        *)
          print_usage_and_exit
        ;;
      esac
    done

    shift `expr "${OPTIND}" - 1`
    [ "${#}" -ne 0 ] && print_usage_and_exit

    return 0
  }

  :<<:
  Variables:
    progpath - This script file full path
    progname - Name of this script file

  Functions:
    _echo() - Most suitable echo command (echo or echo -e).
    _awk() - Most suitable awk command (awk or nawk)
    print_message() - Echo parameters to the original stdout (| for start line)
    print_error() - print_message() to the original stderr
    print_usage_and_exit() - Print usage and exit with argument or 2
    register_for_cleanup() - Add entries to be cleaned up. Variables OK.
    suppress_error_output() - Redirect stderr to /dev/null for cmdline.
    suppress_output() - Redirect stdout and stderr to /dev/null for cmdline.
    trace_and_run() - Print cmdline if TRACE is yes, then execute.

    figure_full_program_path()
    figure_full_path()
    find_file_in_path()
    resolve_symlink()
    resolve_symlink_chain()

    is_list_member()
    is_path()
    is_absolute_path()
    is_regular_file()
    is_program()
  :

  figure_full_program_path()
  {
    file="${1}"
    is_path "${file}" || {
      file=`find_file_in_path "${file}" "${PATH}"`
    }
    figure_full_path "${file}"
  }

  figure_full_path()
  {
    echo `absolute_location "${1}"`/`basename "${1}"`
  }

  find_file_in_path()
  {
    file="${1}"
    path="${2}"

    ifs="${IFS}"
    IFS=:
    set entry ${path}
    shift
    IFS="${ifs}"

    for directory in "${@}"; do
      path="${directory}/${file}"
      is_regular_file "${path}" && {
        _echo "${path}"
        return 0
      }
    done
    return 1
  }

  resolve_symlink()
  {
    set entry `resolve_symlink_chain "${@}"`
    echo "${2}"
  }

  resolve_symlink_chain()
  {
    file="${1}"
    set entry `suppress_error_output "ls -ld '${file}'"`

    case "${2}" in
      l*)
        shift `expr "${#}" - 1`

        link="${1}"
        is_absolute_path "${link}" || {
          link=`dirname "${file}"`/${link}
        }
        echo `resolve_symlink_chain "${link}"` "${file}"
      ;;
      *)
        echo "${file}"
      ;;
    esac
  }

  absolute_location()
  {
    (cd `dirname "${1}"` && pwd)
  }

  is_list_member()
  {
    item="${1}"
    shift

    for entry in "${@}"; do
      [ "${entry}" = "${item}" ] && return 0
    done

    return 1
  }

  is_path()
  {
    case "${1}" in
      /* | */* | */ )
        return 0
      ;;
    esac

    return 1
  }

  is_absolute_path()
  {
    case "${1}" in
      /*)
        return 0
      ;;
    esac

    return 1
  }

  is_regular_file()
  {
    suppress_output "ls -ldL '${1}' | grep '^-'"
  }

  invoke_file_command()
  {
    file `resolve_symlink "${1}"`
  }

  is_program()
  {
    file="${1}"
    is_regular_file "${file}" && {
      suppress_output "invoke_file_command '${file}' | grep 'executable'"
    }
  }

  print_usage_and_exit()
  {
    print_usage
    exit "${1:-2}"
  }

  print_message()
  {
    _echo "${@}" | sed '/^[ \t]*$/d;s/^[ \t]*|//' 1>&3 
  }

  print_error()
  {
    print_message "${@}" 3>&4
  }

  suppress_output()
  {
    "${@}" >/dev/null 2>&1
  }

  suppress_error_output()
  {
    "${@}" 2>/dev/null
  }

  trace_and_run()
  {
    [ "${TRACE}" = yes ] && {
      print_error "=> ${@}"
    }
    "${@}"
  }

  cleanup_list=
  register_for_cleanup()
  {
    for item in "${@}"; do
      cleanup_list="${item}<:>${cleanup_list}"
    done
  }

  cleanup()
  {
    ifs="${IFS}"
    IFS="<:>"
    set entry ${cleanup_list}
    shift
    IFS="${ifs}"

    for entry in "${@}"; do
      eval entry="${entry}"
      [ "${entry:+set}" = set ] && {
        trace_and_run rm -rf "${entry}"
      }
    done

    cleanup_list=
  }

  cleanup_and_exit()
  {
    cleanup
    exit "${1:-1}"
  }

  if [ "`echo -e`" = "-e" ]; then
    _echo() {
      echo "${@}"
    }
  else
    _echo() {
      echo -e "${@}"
    }
  fi

  if ( nawk 'BEGIN { exit 0 }' ) >/dev/null 2>&1; then
    _awk() {
      nawk "${@}"
    }
  else
    _awk() {
      awk "${@}"
    }
  fi

  progpath=`figure_full_program_path "${0}"`
  progname=`basename "${progpath}"`

  exec 3>&1 4>&2

  main "${@}"
  exit ${?}
